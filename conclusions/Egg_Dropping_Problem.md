
## 扔鸡蛋问题
经典的动态规划问题，题设是这样的：
如果你有2颗鸡蛋，和一栋36层高的楼，现在你想知道在哪一层楼之下，鸡蛋不会被摔碎，应该如何用最少的测试次数对于任何答案楼层都能够使问题得到解决。
1. 如果你从某一层楼扔下鸡蛋，它没有碎，则这个鸡蛋你可以继续用
2. 如果这个鸡蛋摔碎了，则你可以用来测试的鸡蛋减少一个
3. 所有鸡蛋的质量相同（都会在同一楼层以上摔碎）
4. 对于一个鸡蛋，如果其在楼层i扔下的时候摔碎了，对于任何不小于i的楼层，这个鸡蛋都会被摔碎
5. 如果在楼层i扔下的时候没有摔碎，则对于任何不大于i的楼层，这颗鸡蛋也不会摔碎
6. 从第1层扔下，鸡蛋不一定完好，从第36层扔下，鸡蛋也不一定会摔碎。

> 实际上，我们的终极目的是要找出连续的两层楼 `i, i+1` 在楼层 `i` 鸡蛋没有摔碎，在楼层 `i+1` 鸡蛋碎了。
> 问题的关键之处在于，测试之前，你并不知道鸡蛋会在哪一层摔碎，你需要找到的是一种测试方案，这种测试方案，无论鸡蛋会在哪层被摔碎，都至多只需要 `m` 次测试，在所有这些测试方案中，`m` 的值最小。

Example 1: `n = 1, k = 36`。 此时只有一个鸡蛋，我们只能从第 1 层开始，逐层往上进行测试。
如果随机选择一个大于 `1` 的楼层 `i` 进行测试，如果鸡蛋碎了，我们无法确定到底是在 `1, 2, ..., i-1, i` 的哪一层鸡蛋开始摔碎的。所以必须从第 `1` 层开始逐层的测试。
所以 `1` 个鸡蛋去测试 `36` 层楼时，最少的测试次数是 36 次，也就是至少需要 36 次测试才能保证检测处鸡蛋开始摔碎的楼层。
又比如说只能进行 35 次测试，如果前 35 层鸡蛋都不会发生破裂，那么需要继续测试第 `36` 层，**因为我们无法确定鸡蛋从第 36 丢下去是否会发生破裂**。

Example 2: `n = 2, k = 36`。此时有两个鸡蛋，我们将会有更多的选择。          
首先，我们可能考虑在第 `18` 层扔第 `1` 个鸡蛋：
1. 如果鸡蛋摔碎了，则用第 `2` 颗鸡蛋从第 `1` 层开始，到第 `17` 层，逐层进行测试，直到找出答案；
2. 如果鸡蛋没碎，则可以用第 `1` 颗鸡蛋从第 `27` 层开始测试，如果碎了，则用第 `2` 颗鸡蛋在第 `19 ~ 26` 层之间逐层测试；如果没碎，则在 `(28 + 36) / 2 = 32` 继续用第 `1` 个鸡蛋测试。如果鸡蛋一直不碎的话，那么问题就像二分查找一样。

当鸡蛋在 `17/18` 层破碎的时候，这种解决方案会出现最坏的结果，也就是 `18`。也就是这种情况：第一个鸡蛋在第 `18` 层摔碎，我们需要用第 `2` 颗鸡蛋从第 `1` 层到 第 `17` 层进行逐层的测试。所以至少 `18` 次。
但是 `18` 并不是问题 `n = 2, k = 36` 的最小值，最小值是 `8`。(待思考)

此时，可以将问题简记为 `W(n, k)`，其中 `n` 为可用于测试的鸡蛋数，`k` 代表被测试的层数。
对于 `n = 2, k = 36` 的问题，可以进行如下考虑：
将第 `1` 颗鸡蛋从第 `i` 层扔下(i 可以为 `[1, k]` 之间的任意值)。如果鸡蛋碎了，则需要用第 `2` 颗鸡蛋解决子问题 `W(1, i-1)`，也就是用 `1` 颗鸡蛋对 `i - 1` 层进行测试。如果鸡蛋没碎，则需要用 2 颗鸡蛋解决子问题 `W(2, 36-i)`，也就是用 `2` 颗鸡蛋测试从第 `i+1` 层到第 `36` 层。
解决以上两个子问题分别得到尝试次数 `p, q`(i.e. `W(1, i-1) = p` and `W(2, 36-i) = q`)，我们取两者之中的最大值，再加上第 `1` 颗鸡蛋在第 `i` 层进行的测试这次。则有 `max(p, q) + 1 = ti` 就是解决 `W(2, 36)` 问题的最小次数。
对于第 1 次测试时 `i` 的选择，有 `k` 种，所以可以得到 36 中解决方案次数: `T = {t1, t2, ..., t36}`。在这些结果中选择最小的 `ti`，也就是对于集合 `T` 中的任意值 `tj (1<=j<=36, j!=i)`，都有 `ti<=tj` 成立。最后 `ti` 就是我们问题的答案。
用公式来描述就是 `W(n, k) = 1 + min(max(W(n-1, x-1), W(n, k-x))), x in {2, 3, ..., k}`，`x` 就是第一次测试时鸡蛋的位置。

这个问题有几个基础的 cases：
`W(1, k) = k`, 也就是用 `1` 颗鸡蛋去测试 `k` 层楼，至少需要 `k` 次测试；
`W(0, k) = 0`, 也就是用 `0` 颗鸡蛋去测试 `k` 层楼，只有 `0` 次的测试；
`W(n, 0) = 0`, 也就是只有 `0` 层楼的时候，只要 `0` 次测试。

在计算 `W(2, 26)` 之前，我们先需要计算出所有的 `W(1, 0), ..., W(1, 36) and W(2, 0), W(2, 1), ..., W(2, 35)` 这些值，可以用递推的方法实现。

```c++
unsigned int DroppingEggsPuzzle(unsigned int eggs, unsigned int floors)
{
	unsigned int i, j, k, t, max;
 
	unsigned int temp[eggs + 1][floors + 1];
 
	for(i = 0; i < floors + 1; ++i)
	{
		temp[0][i] = 0;
		temp[1][i] = i;
	}
 
	for(i = 2; i < eggs + 1; ++i)
	{
		temp[i][0] = 0;
		temp[i][1] = 1;
	}
 
	for(i = 2; i < eggs + 1; ++i)
	{
		for(j = 2; j < floors + 1; ++j)
		{
			for(k = 1, max = UINT_MAX; k < j; ++k)
			{
				t = temp[i][j - k] > temp[i - 1][k -1] ?  temp[i][j - k] : temp[i - 1][k -1];
 
				if(max > t)
				{
					max = t;
				}
			}
 
			temp[i][j] = max + 1;
		}
	}
 
	return temp[eggs][floors];
}
```
> 该算法的空间复杂度是 `O(nk)`，时间复杂度是 `O(nk^2)`，对于规模较大的问题，无论是空间还是时间复杂度都很可观。

用这个算法可以计算出 `W(2, 36)` 问题的最少测试次数是 8。
一种可行的测试方案如下：
1. 用第一颗鸡蛋分别在 `8, 15, 21, 26, 30, 33, 35` 层进行测试；
2. 如果鸡蛋在某一层碎了(例如 `26` 层)，则在前一测试点由下到上依次测试，例如 `22, 23, 24, 25`，直到找到满足条件的楼层为止；
3. 如果鸡蛋在第 `35` 层的测试中也没碎，则用该鸡蛋在第 `36` 层再测试一次。

如果在第 `8` 层碎了，则需要从第 `1` 层开始到第 `7` 层进行逐层的测试，也就是需要 8 次；
如果在第 `8` 层没有碎，则继续用第 `1` 颗鸡蛋在第 `15` 层进行测试。(此时 `15` 选择的并不是中位数。)   
    如果碎了，`9, 10, 11, 12, 13, 14`，最多也是 8 次。
    如果没有碎，则再用第 `1` 颗鸡蛋在第 `21` 层进行测试，如此往复。
    
所以该方案可以保证，无论满足条件的楼层是多少，都可以在最多 `8` 次测试之后找到要的答案。


## 扔鸡蛋问题的引出问题 ???
如果我们有 `n` 鸡蛋，测试 `m` 次，(简记为 `D(n, m)`)，最大可以解决几层楼的问题。通过对递归结果表格的观察，可以得到如下结论：(Reference 1)
1. `D(1, m) = m`. 对于只有 `1` 个鸡蛋的情况，需要测试的次数与楼层的次数一致；
2. `D(n, n) = 2 ^ n - 1`，
3. `D(n, m) {m <= n} = D(m, m)` 

基于以上观察，如何解决 `n` 个鸡蛋测试 `m` 次，最多能够测试多少层楼？
`D(n, m) = D(n-1, m-1) + 1 + D(n, m-1)`

## Reference:
1. [扔鸡蛋问题详解（Egg Dropping Puzzle）](https://blog.csdn.net/joylnwang/article/details/6769160)


