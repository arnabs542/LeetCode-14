


Key Points:
1. **Def:** `dp[i]` indicates whether an array of length `i` can be partitioned into k
subsets of equal sum. Then the last index of this `dp` array will tell whether the
whole array can be partitioned into k subsets of equal sum.
`total[i]` stores the sum of subset with sum less than or equal to target sum
(i.e. total sum / k. Because we need to split array into k subsets).
2. `dp[i]` represents the validity of the `i-th` subset, where **validity** means:
at each step when an element is inserted into this subset, the sum of elements is
always <= target. 这里的 `dp[i]` 只代表**有效性**。
3. `for(int i=0; i<(1<<n); i++) {}`, i.e. `i` is in the range `[0,...,2^n-1]`, where
each number `i` represents a subset.

```java
class Solution {
    public boolean canPartitionKSubsets(int[] nums, int k) {
        if(nums == null || nums.length == 0) {
            return false;
        }
        
        int n = nums.length;
        // Result array
        boolean[] dp = new boolean[1 << n]; // 1 << n, i.e. 2^n, i.e. dp[0,...,2^n-1]
        int[] total = new int[1 << n];      // 1 << n, i.e. 2^n, i.e. total[0,...,2^n-1]
        dp[0] = true;
        
        int sum = 0;
        for(int num: nums) {
            sum += num;
        }
        Arrays.sort(nums);
        
        if(sum % k != 0) {  // undividable
            return false;
        }
        
        sum /= k;   // the target sum is sum / k, i.e the sum of each subset
        if(nums[n-1] > sum) {   // if the largest number is larger than sum, no subset can include this number
            return false;
        }
        
        // Loop over power set
        for(int i=0; i< (1 << n); i++) {    // i is in the range of [0,...,2^n-1]
            if(dp[i]) {
                // Loop over each element to find subset
                for(int j=0; j<n; j++) {
                    // set the j-th bit
                    int tmp = i | (1 << j);
                    if(tmp != i) {  // tmp != i, i.e add j-th number successfully
                        // if total sum is less tha target store in dp and total array
                        if(nums[j] <= (sum - (total[i] % sum))) {
                            dp[tmp] = true;
                            total[tmp] = nums[j] + total[i];
                        } else {    // ie. nums[j] > (sum - (total % sum))
                            break;
                        }
                    }
                }
            }
        }
        return dp[(1 << n) - 1];
    }
}
```