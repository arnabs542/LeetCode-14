[103. Binary Tree Zigzag Level Order Traversal](https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/)

* Amazon, Microsoft, ByteDance, Facebook, Apple, eBay, Qualtrics, 
* Stack, Tree, Breadth-First Search
* Similar Questions:
    * 102.Binary Tree Level Order Traversal



## Method 1. Recursion

Key Points:

1. We need know the level of each `List` we are using, since we need to determine where to add new element, the head or the tail.

```java 
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<List<Integer>>();
        Map<Integer, LinkedList<Integer>> map = new HashMap<Integer, LinkedList<Integer>>();
        helper(root, 0, map);
        for(int key: map.keySet()) {
            res.add(map.get(key));
        }
        return res;
    }
    
    private void helper(TreeNode node, int depth, Map<Integer, LinkedList<Integer>> map) {
        if(node == null) {  // Avoid null here
            return;
        }
        if(!map.containsKey(depth)) {
            map.put(depth, new LinkedList<Integer>());
        }
        if(depth % 2 == 0) {
            map.get(depth).add(node.val);
        } else {
            map.get(depth).addFirst(node.val);
        }
        helper(node.left, depth+1, map);
        helper(node.right, depth+1, map);
    }
}
```

Complexity Analysis

    Time complexity : O(N) since each node is processed exactly once.
    Space complexity : O(N) to keep the output structure which contains N node values. 



## Method 2. BFS

```java 
class Solution {
    public List<List<Integer>> zigzagLevelOrder(TreeNode root) {
        List<List<Integer>> res = new ArrayList<>();
        
        if(root == null) {
            return res;
        }
        
        Deque<TreeNode> queue = new ArrayDeque<>();
        queue.offer(root);
        boolean forward = true;
        
        while(!queue.isEmpty()) {
            List<Integer> tmp = new LinkedList<Integer>();
            int size = queue.size();
            for(int i=0; i<size; i++) {
                TreeNode curr = queue.poll();
                if(forward) {
                    tmp.add(curr.val);
                } else {
                    tmp.add(0, curr.val);
                }
                
                if(curr.left != null) {
                    queue.offer(curr.left);
                }
                if(curr.right != null) {
                    queue.offer(curr.right);
                }
            }
            res.add(tmp);
            forward = !forward;		// flip direction
        }
        return res;
    }
}
```



## Reference

* [Solution](https://leetcode.com/problems/binary-tree-level-order-traversal/solution/)